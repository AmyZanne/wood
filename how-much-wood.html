<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>How much of the world is woody, first analysis.</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link rel="stylesheet" href="stylesheet.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">How much of the world is woody, first analysis.</h1>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(multicore)
<span class="kw">library</span>(diversitree)</code></pre>
<pre><code>## Loading required package: deSolve</code></pre>
<pre><code>## Loading required package: ape</code></pre>
<pre><code>## Loading required package: subplex</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(RColorBrewer)
path.forest &lt;- <span class="kw">readLines</span>(<span class="st">&quot;~/.forest_path&quot;</span>)
<span class="kw">source</span>(<span class="st">&quot;functions.R&quot;</span>)
<span class="kw">source</span>(<span class="st">&quot;build-family-tree.R&quot;</span>)

read.forest.csv &lt;- function(filename) <span class="kw">read.csv</span>(<span class="kw">file.path</span>(path.forest, filename), 
    <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

dat &lt;- <span class="kw">read.forest.csv</span>(<span class="st">&quot;export/speciesTraitData.csv&quot;</span>)</code></pre>
<p>Extract the woodiness data:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat$woodiness[!(dat$woodiness %in% <span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;W&quot;</span>)) &amp; !<span class="kw">is.na</span>(dat$woodiness)] &lt;- <span class="ot">NA</span>
x &lt;- <span class="kw">factor</span>(dat$woodiness)
<span class="kw">names</span>(x) &lt;- dat$gs
x &lt;- x[!<span class="kw">is.na</span>(x)]

info &lt;- <span class="kw">read.forest.csv</span>(<span class="st">&quot;taxonomic/spermatophyta_richnesses.plantlist.APGIIItax.csv&quot;</span>)</code></pre>
<p>Determine orders:</p>
<pre class="sourceCode r"><code class="sourceCode r">lookup &lt;- <span class="kw">read.forest.csv</span>(<span class="st">&quot;taxonomic/genus_order_lookup.csv&quot;</span>)</code></pre>
<p>Currently, some orders are missing for individual genera that belong to families where the order relationship is already known. Fill these in:</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;- lookup$order == <span class="st">&quot;&quot;</span> &amp; lookup$family != <span class="st">&quot;&quot;</span>
tmp &lt;- lookup[lookup$order != <span class="st">&quot;&quot;</span>, ]
res &lt;- tmp$order[<span class="kw">match</span>(lookup$family[i], tmp$family)]
res[<span class="kw">is.na</span>(res)] &lt;- <span class="st">&quot;&quot;</span>
lookup$order[i] &lt;- res</code></pre>
<p>Add order level to info, which also contains per-genus counts.</p>
<pre class="sourceCode r"><code class="sourceCode r">info$order &lt;- lookup$order[<span class="kw">match</span>(info$family, lookup$family)]
info$order[<span class="kw">is.na</span>(info$order) | info$order == <span class="st">&quot;&quot;</span>] &lt;- <span class="st">&quot;UnknownOrder&quot;</span></code></pre>
<p>Extract genus for each observation to match against the 'info' table.</p>
<pre class="sourceCode r"><code class="sourceCode r">genus &lt;- <span class="kw">sub</span>(<span class="st">&quot; .+&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="kw">names</span>(x))</code></pre>
<p>Filter for known-ness (there is a lookup issue here to resolve, dropping about 2400 species). This filters both the genus names and the data.</p>
<pre class="sourceCode r"><code class="sourceCode r">ok &lt;- genus %in% info$genus
x &lt;- x[ok]
genus &lt;- genus[ok]
genus &lt;- <span class="kw">factor</span>(genus, <span class="dt">levels =</span> <span class="kw">sort</span>(<span class="kw">unique</span>(info$genus)))</code></pre>
<p>'dat.g' is grouped by genus, and contains known numbers of species (N), and numbers known to be woody (W) and herbacious (H).</p>
<pre class="sourceCode r"><code class="sourceCode r">dat.g &lt;- <span class="kw">as.data.frame</span>(<span class="kw">unclass</span>(<span class="kw">table</span>(genus, x)))
idx &lt;- <span class="kw">match</span>(<span class="kw">rownames</span>(dat.g), info$genus)
dat.g &lt;- <span class="kw">cbind</span>(<span class="dt">order =</span> info$order[idx], <span class="dt">family =</span> info$family[idx], <span class="dt">genus =</span> <span class="kw">rownames</span>(dat.g), 
    <span class="dt">N =</span> info$species[idx], dat.g)
dat.g &lt;- dat.g[<span class="kw">order</span>(dat.g$order), ]
<span class="kw">rownames</span>(dat.g) &lt;- <span class="ot">NULL</span></code></pre>
<p>For some species, we know about more states than we know about species; increase the species count in this case.</p>
<pre class="sourceCode r"><code class="sourceCode r">fix &lt;- <span class="kw">with</span>(dat.g, N &lt; H + W)
dat.g$N[fix] &lt;- <span class="kw">with</span>(dat.g[fix, ], H + W)</code></pre>
<p>Finally, estimate the fraction of known states are woody:</p>
<pre class="sourceCode r"><code class="sourceCode r">dat.g$p &lt;- <span class="kw">with</span>(dat.g, W/(H + W))</code></pre>
<p>Here is the simulator. For each genus, sample unknown species from a hypergeometric distribution with parameters sampled from the known number of woody, herbacious and known species. With this sampled data, sample proportions of woody species for the genera with nothing known from the empirical distribution of woodiness, and sample woody/herbacious species from a binomial.</p>
<pre class="sourceCode r"><code class="sourceCode r">sim &lt;- function(x, nrep) {
    i &lt;- <span class="kw">is.na</span>(x$p)
    w &lt;- <span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="kw">nrow</span>(x), nrep)
    n.unk &lt;- <span class="kw">sum</span>(i)
    w[!i, ] &lt;- <span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">which</span>(!i), function(j) <span class="kw">rhyper2</span>(nrep, x$H[j], x$W[j], 
        x$N[j])))
    w[i, ] &lt;- <span class="kw">apply</span>(w[!i, , <span class="dt">drop =</span> <span class="ot">FALSE</span>]/x$N[!i], <span class="dv">2</span>, function(y) <span class="kw">rbinom</span>(n.unk, 
        x$N[i], <span class="kw">quantile</span>(y, <span class="kw">runif</span>(n.unk))))
    
    ## This is surprisingly convoluted:
    fam &lt;- <span class="kw">as.character</span>(x$family)
    ret &lt;- <span class="kw">t</span>(<span class="kw">sapply</span>(<span class="kw">split</span>(<span class="kw">as.data.frame</span>(w), fam), colSums))
    <span class="kw">colnames</span>(ret) &lt;- <span class="ot">NULL</span>
    ret
}</code></pre>
<p>Sample the fraction 1000 times. This takes a while - currently about 1.5 minutes.</p>
<pre class="sourceCode r"><code class="sourceCode r">nrep &lt;- <span class="dv">1000</span>
dat.g.split &lt;- <span class="kw">split</span>(dat.g, dat.g$order)
simulated.counts &lt;- <span class="kw">mclapply</span>(dat.g.split, sim, nrep)</code></pre>
<p>Next, build collapsed sets of data by family and by order.</p>
<pre class="sourceCode r"><code class="sourceCode r">tot.f &lt;- <span class="kw">do.call</span>(rbind, simulated.counts)
tot.o &lt;- <span class="kw">do.call</span>(rbind, <span class="kw">lapply</span>(simulated.counts, colSums))</code></pre>
<p>Number of species per family and order:</p>
<pre class="sourceCode r"><code class="sourceCode r">n.f &lt;- <span class="kw">tapply</span>(dat.g$N, dat.g$family, sum)[<span class="kw">rownames</span>(tot.f)]
n.o &lt;- <span class="kw">tapply</span>(dat.g$N, dat.g$order, sum)[<span class="kw">rownames</span>(tot.o)]</code></pre>
<p>From this, compute the per-family and per-order fraction</p>
<pre class="sourceCode r"><code class="sourceCode r">prop.f &lt;- tot.f/<span class="kw">rep</span>(n.f, nrep)
prop.o &lt;- tot.o/<span class="kw">rep</span>(n.o, nrep)
prop.all &lt;- <span class="kw">colSums</span>(tot.o)/<span class="kw">sum</span>(n.o)</code></pre>
<p>And the mean fraction woody per family and order:</p>
<pre class="sourceCode r"><code class="sourceCode r">p.f &lt;- <span class="kw">rowMeans</span>(prop.f)
p.o &lt;- <span class="kw">rowMeans</span>(prop.o)
p.all &lt;- <span class="kw">mean</span>(prop.all)</code></pre>
<p>Here is a function that converts a value on 0..1 to increasingly dark blues.</p>
<pre class="sourceCode r"><code class="sourceCode r">cols &lt;- function(x) {
    tmp &lt;- <span class="kw">colorRamp</span>(<span class="kw">brewer.pal</span>(<span class="dv">9</span>, <span class="st">&quot;Blues&quot;</span>))(x)
    <span class="kw">rgb</span>(tmp[, <span class="dv">1</span>], tmp[, <span class="dv">2</span>], tmp[, <span class="dv">3</span>], <span class="dt">max =</span> <span class="dv">255</span>)
}</code></pre>
<p>Histogram of woodiness</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>))
<span class="kw">hist</span>(prop.all, <span class="dt">xlab =</span> <span class="st">&quot;Percent woody&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">bty =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>, 
    <span class="dt">col =</span> <span class="kw">cols</span>(p.all))</code></pre>
<div class="figure">
<img src="figure/unnamed-chunk-17.png" alt="Estimated fraction of woodiness over vascular plants" /><p class="caption">Estimated fraction of woodiness over vascular plants</p>
</div>
<p>Plot the tree with a distribution of fractions of woodiness per family around the outside.</p>
<pre class="sourceCode r"><code class="sourceCode r">phy.f &lt;- <span class="kw">build.family.tree</span>()</code></pre>
<p>This tree has order information:</p>
<pre class="sourceCode r"><code class="sourceCode r">phy.f.ord &lt;- phy.f$class</code></pre>
<p>Drop tips with no woodiness estimates (due to taxonomic differences)</p>
<pre class="sourceCode r"><code class="sourceCode r">to.drop &lt;- <span class="kw">setdiff</span>(phy.f$tip.label, <span class="kw">names</span>(p.f))
phy.f &lt;- diversitree:::<span class="kw">drop.tip.fixed</span>(phy.f, to.drop)</code></pre>
<p>And sort the order information by the current taxon labels:</p>
<pre class="sourceCode r"><code class="sourceCode r">phy.f.ord &lt;- <span class="kw">unname</span>(phy.f.ord[phy.f$tip.label])</code></pre>
<p>Identify the nodes corresponding to orders, and plot the internal ones.</p>
<pre class="sourceCode r"><code class="sourceCode r">plt &lt;- <span class="kw">trait.plot.cont</span>(phy.f, p.f, <span class="kw">list</span>(cols), <span class="dt">class =</span> phy.f.ord, <span class="dt">w =</span> <span class="dv">1</span>/<span class="dv">30</span>, 
    <span class="dt">font =</span> <span class="dv">1</span>)</code></pre>
<pre><code>## Warning: Collapsing non-monophyletic groups: Malpighiales, Arecacales</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">mrca.tipset &lt;- diversitree:::mrca.tipset
nd &lt;- <span class="kw">sapply</span>(<span class="kw">sort</span>(<span class="kw">unique</span>(phy.f.ord)), function(x) <span class="kw">mrca.tipset</span>(phy.f, phy.f$tip.label[phy.f.ord == 
    x &amp; !<span class="kw">is.na</span>(phy.f.ord)]))
nd.int &lt;- nd[nd &gt; <span class="kw">length</span>(phy.f$tip.label)]
<span class="kw">points</span>(plt$xy$xx[nd.int], plt$xy$yy[nd.int], <span class="dt">pch =</span> <span class="dv">19</span>, <span class="dt">cex =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="kw">cols</span>(p.o[<span class="kw">names</span>(nd.int)]))</code></pre>
<div class="figure">
<img src="figure/unnamed-chunk-22.png" alt="Estimated per-family and per-order woodiness proportions" /><p class="caption">Estimated per-family and per-order woodiness proportions</p>
</div>
</body>
</html>
